<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/papaparse.js"></script>
    <script src="/js/d3.js"></script>
    <script src="/js/moment.js"></script>
    <link href="https://fonts.googleapis.com/css?family=ABeeZee" rel="stylesheet">
    
    <title>oi</title>
  </head>
  <body>

    <style>
      body {
        padding: 10px;
      }

      .label-user {
        position: absolute;
        top: 50px;
        font-size: 10px;
        font-family: 'ABeeZee', sans-serif;
        transform: rotateZ(-45deg);
        transform-origin: top left;
      }

      div.tooltip {	
        position: absolute;
        max-width: 240px;		
        min-width: 120px;
        padding: 2px;				
        font-family: 'ABeeZee', sans-serif;		
        font-size: 8px;
        background: rgba(255,255,255,0.7);	
        padding: 3px;
        border-radius: 2px;
        pointer-events: none;
        box-shadow: 0 1px 4px rgba(0,0,0,0.2);	
      }


    </style>

    <script>

      var dados = [], users = [], max_delta_t = [];
      Papa.parse("tweets_classificados.csv", {
        download: true,
        header: true,
        complete: function(results) {
          
          // daqui: https://stackoverflow.com/questions/17780508/selecting-distinct-values-from-a-json
          
          var lookup = {};
          var items = results.data;
          
          for (var item, i = 0; item = items[i++];) {
            var user = item.id;
          
            if (!(user in lookup)) {
              lookup[user] = 1;
              users.push(user);
              dados_de_um = monta_array_user(user, results.data); 
              dados.push(dados_de_um);
              max_delta_t.push(d3.max(dados_de_um.map(function(d) {
                return d.delta_t;
              })));
            }
          }

          var min_max = acha_min_max_geral(results.data);

          desenha(dados, users, max_delta_t, min_max);

        }
      });

      function acha_min_max_geral(results) {
        milisegundos = [];
        for (i = 0; i < results.length; i++) {
          milisegundos.push(Date.parse(results[i].data)); // está em milisegundos. quero em segundos
        }
        return [
          d3.min(milisegundos),
          d3.max(milisegundos)
        ];
      }

      function conv_valencia(val) {
        return (val - 4)/3; // de -1 a 1
      }

      function conv_intensidade(inten) {
        return (inten - 1)/6; // de 0 a 1
      }

      function monta_array_user(user, dados) {

        var array_user = [];

        var s0, s1 = null;
        var t0;

        for (var i = 0; i < dados.length; i++) {
          if (dados[i].id == user) {

            array_user.push({});
            i2 = array_user.length - 1;

            // calcula distância de tempo
            if (s1 == null) { // primeira vez
              array_user[i2]["delta_t"] = 0;
              array_user[i2]["delta_abs"] = 0;
              s1 = Date.parse(dados[i].data);
              t0 = s1;
            } else {
              s0 = s1;
              s1 = Date.parse(dados[i].data);
              var delta_t = s0 - s1; // qtos segundos entre eles?
              array_user[i2]["delta_t"] = delta_t;

              array_user[i2]["delta_abs"] = t0 - s1; // qtos segundos entre o tweet mais recente e este?

            }

            // outras informações

            array_user[i2]["tweet"] = dados[i].txt;
            array_user[i2]["timestamp"] = moment(dados[i].data);
            array_user[i2]["valencia"] = conv_valencia(dados[i].val);
            array_user[i2]["intensidade"] = conv_intensidade(dados[i].int);

          }
        }

        return array_user;
      } 


      var div = d3.select("body").append("div")	
                    .attr("class", "tooltip")				
                    .style("opacity", 0);

      // ref: d3.min; d3.max; d3.extent [min e max]
      // d3.sum; d3.mean; d3.median; d3.shuffle

      var inicio_fds = 19,
      fim_fds = 19;


      function distancia_ate_fds(time) {
        var deltas = {};
        var momento_atual = moment(time);

        if ( (momento_atual.day() == 0 && momento_atual.hour() <= fim_fds)  // fds acaba às 16h do domingo?
          || (momento_atual.day() == 5 && momento_atual.hour() >= inicio_fds)  // fds começa às 21h da sexta?
          || (momento_atual.day() == 6)) { // sabadão é fds

          deltas["eh_fds"] = true;
          // calcular qtos segundos até o fim
          var proximo_domingo = moment(moment(time).endOf("week").add(fim_fds,'h')); // domingo é o primeiro dia da semana, então preciso medir sábado + 16 horas do domingo...
          deltas["delta_msegundos"] = moment.duration(proximo_domingo.diff(momento_atual)).asMilliseconds();

        } else { // ok, não estamos em um, então medir distância até o início do próximo

          deltas["eh_fds"] = false;
          // calcular segundos até sexta às 21h: acho o fim do sábado, tiro 1 dia, tiro 1 dia menos 21h da noite
          var inicio_fds = moment(moment(time).endOf("week").subtract(24+(24-inicio_fds),'h'));
          deltas["delta_msegundos"] = moment.duration(inicio_fds.diff(momento_atual)).asMilliseconds();
        }

        return deltas;
      }

      function monta_array_periodos(init_time, duracao_total) {
        //             inicio_fds/sexta            +   sábado     + 0-fim_fds/domingo  * ms
        var duracao_fds = ((24-inicio_fds) * 60 * 60 + 24 * 60 * 60 + fim_fds * 60 * 60) * 1000;
        var duracao_semana = (7 * 24 * 60 * 60) * 1000 - duracao_fds; // o resto
        
        var array_periodos = [];
        var delta = distancia_ate_fds(init_time);

        array_periodos.push([delta["delta_msegundos"], 0, delta["eh_fds"]]);
        duracao_total -= delta["delta_msegundos"];
        
        var y_anterior = delta["delta_msegundos"];
        var eh_fds = !delta["eh_fds"];

        while (duracao_total > 0) {

          var duracao;

          if (eh_fds) {
            duracao = duracao_fds;
          } else {
            duracao = duracao_semana;
          }

          array_periodos.push([duracao, y_anterior, eh_fds]);

          duracao_total -= duracao;
          y_anterior += duracao;
          eh_fds = !eh_fds;
        }

        return array_periodos;

      }


      
      function desenha(dados, users, max, min_max) {

        function plota_fds(canvas, dados, n_users, y_ms) {

          var rects = canvas.selectAll("rects")
                      .data(dados)
                      .enter()
                      .append("rect")
                        .attr("width", n_users * delta_x_user)
                        .attr("y", function(d) {
                          y = (d[1]*y_ms) + pad + pad_text;
                          return y;
                        })
                        .attr("height", function(d, i) {
                          var n_height = d[0] * y_ms;
                          // console.log(i + " " + n_height);
                          if (d[2] || true) {
                            return n_height;
                          }
                          // return 2; // dias da semana = só uma linha
                        })
                        .attr("fill", function(d) {
                          if (d[2]) { //eh_fds
                            return "rgba(0,0,50,0.1)";
                          } 
                          return "rgba(0,0,0,0.05)"
                        });
        }


        function plota_um_usuario(canvas, dados, user, max, i) {

          var text = d3
                    .select("body")
                    .append("p")
                    .text(user)
                    .attr("class","label-user")
                    .style("left", (i * 100 + pad) + "px");


          var circs = canvas.selectAll("circs")
              .data(dados)
              .enter()
              .append("circle")
                .attr("cx", delta_x_user * i + pad)
                .attr("cy", function(d, i) {
                  var y = time_scale(d.delta_abs) + pad + pad_text;
                  // console.log(user + " > " + y);
                  return y;
                })
                .attr("r",function(d) {
                  return intensity_scale(d.intensidade);
                })
                .attr("fill",function(d) {
                  return valence_color_scale(d.valencia);
                })
                .attr("stroke","black")
                .attr("stroke-width","0")
                // http://bl.ocks.org/d3noob/a22c42db65eb00d4e369
                .on("mouseover", function(d) {
                  d3.select(this)
                    .attr("stroke-width","1");
                  d3.select(".tooltip")
                    	.html(d.tweet + "<br><br>" + d.timestamp.format('llll'))	
                      .style("left", (d3.event.pageX + 20) + "px")
                      .style("top", (d3.event.pageY - 28) + "px")
                      .style("opacity",1);	
                })					
                .on("mouseout", function(d) {	
                  d3.select(this)
                    .attr("stroke-width","0");	
                  d3.select(".tooltip")	
                    .style("opacity", 0);
                });

          return circs;

        }

        function y_total(min_t, max_t, y_dia, ms_dia) {
          return (max_t - min_t) * y_dia / ms_dia;
        }
 
        var delta_x_user = 100;
        var pad = 40;
        var pad_text = 50;
        

        var ms_dia = 24 * 60 * 60 * 1000;
        var y_dia = 200;
        var max_geral = d3.max(max);

        var intensity_scale = d3.scaleLinear()
                                .domain([0, 1])
                                .range([0, 30]);
                                
        var valence_color_scale = d3.scaleLinear()
                                  .domain([-1,0,1])
                                  .range(["rgba(255,0,0,0.8)","rgba(128,128,128,0.1)","rgba(0,255,0,0.8)"]);

        var time_scale = d3.scaleLinear()
                          .domain([0, ms_dia])
                          .range([0, y_dia]);

        var width = dados.length * delta_x_user + 2 * pad;
        var height = y_total(min_max[0], min_max[1], y_dia, ms_dia) + 2 * pad + pad_text;

        var canvas = d3.select("body")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height)
                      .append("g");

        var array_periodos = monta_array_periodos(min_max[0], min_max[1]-min_max[0]);
        
        plota_fds(canvas, array_periodos, users.length, y_dia/ms_dia);

        for (var i = 0; i < dados.length; i++) {
          plota_um_usuario(canvas, dados[i], users[i], max_geral, i)
        }

      }



        // var color = d3.scaleLinear()
        //               .domain([0, 60])
        //               .range(["red", "blue"]);

        // var xAxis = d3.axisBottom()
        //             .ticks(5)
        //             .scale(widthScale);
        


      // var bars = canvas.selectAll("rect")
      //             .data(dataArray)
      //             .enter()
      //               .append("rect")
      //               .attr("width", function(d) { return widthScale(d); })
      //               .attr("height", 50)
      //               .attr("fill", function(d) { return color(d); })
      //               .attr("y", function(d, i) { return i * 100; });

      // canvas.append("g")
      //   .attr("transform", "translate(0, 400)")
      //   .call(xAxis);


      // duvida: há blur para svg??


    </script>
  </body>
</html>